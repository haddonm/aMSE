

#' @title constCatch implements a constant TAC harvest strategy
#'
#' @description constCatch implements a constant catch harvest strategy. It
#'     distributes the constant TAC across the SAU with respect to the relative
#'     amounts of exploitable biomass present, including some log-normal error
#'     that uses withsigB. It still needs error to be added to the distribution
#'     of each SAUs catch among its component populations
#'
#' @param inTAC the constant catch for the zone, from projC$HSdetail
#' @param zoneCP the list of constants for the projections
#' @param zoneDP the results list zoneDP after it has been generated by
#'     makezoneDR and then had variation added using addrecvar
#' @param glob the global object
#' @param ctrl the control object
#' @param projyrs the number of years of projection from projC$projyrs
#' @param varyrs the number of years used to express starting variation
#'
#' @return a revised zoneDP now containing the dynamics of each replicate run
#' @export
#'
#' @examples
#' print("wait on new data")
constCatch <- function(inTAC,zoneCP,zoneDP,glob,ctrl,projyrs,varyrs=10) {
  sigmar <- ctrl$withsigR
  npop <- glob$numpop
  Ncl <- glob$Nclass
  nyrs <- projyrs + varyrs
  movem <- glob$move
  sauindex <- glob$sauindex
  reps <- ctrl$reps
  matb <- numeric(npop)
  for (iter in 1:reps) {  # iter=1
    for (year in (varyrs+1):nyrs) {
      inexpB <- zoneDP$exploitB[(year - 1),,iter] # each populations exB
      sauexpB <- tapply(inexpB,glob$sauindex,sum) # each SAU exB
      divererr <- sauexpB * exp(rnorm(glob$nSAU,mean=0,sd=ctrl$withsigB))
      catbysau <- inTAC * (divererr/sum(divererr)) # currently no error on TAC
      catbypop <- catbysau[sauindex] * (inexpB/sauexpB[sauindex]) # no error on pops
      for (popn in 1:npop) { # year=11; iter=1; pop=1
        out <- oneyearcat(inpopC=zoneCP[[popn]],inNt=zoneDP$Nt[,year-1,popn,iter],
                          Nclass=Ncl,incat=catbypop[popn],yr=year)
        zoneDP$exploitB[year,popn,iter] <- out$ExploitB
        zoneDP$matureB[year,popn,iter] <- out$MatureB
        zoneDP$catch[year,popn,iter] <- out$Catch
        zoneDP$harvestR[year,popn,iter] <- out$Harvest
        zoneDP$cpue[year,popn,iter] <- out$ce
        zoneDP$Nt[,year,popn,iter] <- out$Nt
        zoneDP$catchN[,year,popn,iter] <- out$CatchN
        matb[popn] <- out$MatureB
      } # pop
      steep <- getvect(zoneCP,"steeph")
      r0 <- sapply(zoneCP,"[[","R0")
      b0 <- sapply(zoneCP,"[[","B0")
      recs <- oneyearrec(steep,r0,b0,matb,sigR=sigmar)
      newrecs <- movem %*% recs
      zoneDP$recruit[year,,iter] <- newrecs
      zoneDP$Nt[1,year,,iter] <- newrecs
      zoneDP$deplsB[year,,iter] <- zoneDP$matureB[year,,iter]/b0
      zoneDP$depleB[year,,iter] <- zoneDP$exploitB[year,,iter]/sapply(zoneCP,"[[","ExB0")
    }   # year loop        zoneDR$matureB[,,1]
  }     # rep loop
  return(zoneDP)
} # end of constCatch



#' @title diagnostics generates an array of diagnostic plots
#'
#' @description diagnostics can generates an array of diagnostic plots,
#'     however, currently it only plots the selectivity
#'
#' @param zoneC the constants for the zone simulated
#' @param zoneD the dynamic aspects of the zone simulated
#' @param glob the general globals
#' @param plot plot the output or not; default = TRUE
#'
#' @return invisibly returns the unique values of LML
#' @export
#'
#' @examples
#' \dontrun{
#'   print("still to devise an example.")
#' }
diagnostics <- function(zoneC,zoneD,glob,plot=TRUE) {   # inzone <- testzone
  useLML <- sapply(zoneC,"[[","LML") # pulls out vectors
  colLML <- apply(useLML,2,unique)
  valLML <- unique(colLML)
  nLML <- length(valLML)
  midpts <- glob$midpts
  Nclass <- glob$Nclass
  plotprep(width=6,height=4)
  plot(midpts,seq(0,1,length=Nclass),type="n",xlab="",
       ylab="",ylim=c(0,1.025),yaxs="i",panel.first=grid())
  for (i in 1:nLML) {
    pick <- which(colLML == valLML[i])
    lines(midpts,zoneC[[pick[1]]]$Select[,1],lwd=2,col=i)
  }
  title(ylab=list("Selectivity", cex=1.0, font=7),
        xlab=list("Shell Length (mm)", cex=1.0, font=7))
  return(invisible(valLML))
}  # end of diagnostics



#' @title initiateHS applies HS to the last years of the historical conditioning
#'
#' @description initiateHS uses the last years of fishery conditioning to run
#'     the HS for the first year of the projections. This fills in the first
#'     row of each of the variables in the dynamic object for each of the
#'     proposed iterations.
#'
#' @param zoneDP the empty dynamics object used in the projections
#' @param zoneCP the constant object after modification for projections
#' @param exb a vector of exploitable biomass for each population from the last
#'     year of the conditioning on the fishery or historical fishery data
#' @param inN an array of the numbers-at-length for each population from the
#'     last year of the conditioning on the fishery or historical fishery data
#' @param acatch the aspirational catches per SAU derived from the conditioning
#'     of the HS based on the historical or fishery conditioning data
#' @param sigmar the recruitment variability (sd) to be used in the projections
#' @param sigmab the variability (sd) applied to the exploitable biomass
#'     estimates to introduce a form of implementation error on the distribution
#'     of catches among SAU
#' @param glb the globals object
#'
#' @return a revised zoneDP object with the first year filled in for each
#'     replicate
#' @export
#'
#' @examples
#' print("wait on suitable internal data sets")
initiateHS <- function(zoneDP,zoneCP,inN,acatch,sigmar,sigmab,glb) {
  reps <- dim(zoneDP$matureB)[3]
  r0 <- getvar(zoneCP,"R0") #sapply(zoneC,"[[","R0")
  b0 <- getvar(zoneCP,"B0") #sapply(zoneC,"[[","B0")
  exb0 <- getvar(zoneCP,"ExB0")
  for (iter in 1:reps) {
    popC <- calcexpectpopC(TAC=0,acatch=acatch,
                           exb=zoneDD$exploitB[year-1,],
                           sauindex,sigmab=sigmab)
    outy <- oneyearsauC(zoneCC=zoneCP,inN=inN,popC=popC,year=1,
                        Ncl=glb$Nclass,sauindex=glb$sauindex,movem=glb$move,
                        sigmar=sigmar)
    dyn <- outy$dyn
    saudyn <- poptosauCE(dyn["catch",],dyn["cpue",],glb$sauindex)
    zoneDP$exploitB[1,,iter] <- dyn["exploitb",]
    zoneDP$matureB[1,,iter] <- dyn["matureb",]
    zoneDP$catch[1,,iter] <- dyn["catch",]
    zoneDP$acatch[1,,iter] <- acatch
    zoneDP$catsau[1,,iter] <- saudyn$saucatch
    zoneDP$harvestR[1,,iter] <- dyn["catch",]/dyn["exploitb",]
    zoneDP$cpue[1,,iter] <- dyn["cpue",]
    zoneDP$cesau[1,,iter] <- saudyn$saucpue
    zoneDP$recruit[1,,iter] <- dyn["recruits",]
    zoneDP$deplsB[1,,iter] <- dyn["deplsB",]
    zoneDP$depleB[1,,iter] <- dyn["depleB",]
    zoneDP$Nt[,1,,iter] <- outy$NaL
    zoneDP$catchN[,1,,iter] <- outy$catchN
  }
  return(zoneDP)
} # end on initiateHS


#' @title makefilename Generates a filename for output files
#'
#' @description makefilename Generates a filename for output files based upon
#'     he name of the HCR (hcrLabel), the runlabel, the number of reps and
#'     the initial depletion (initDepl), which should be sufficient to
#'     uniquely identify any different scenarios to be run
#'     Uses splitDate.
#'
#' @param hcrLabel the name of the harvest strategy beign used
#' @param runlabel the optional additional label for each run
#' @param reps the number of iterations of the MSE run of the dynamics
#' @param initDepl the initial depletion for the zone
#' @return  makefilename generates a filename for output files
#'
#' @export
#' @examples
#' \dontrun{
#'  tmp <- splitDate()
#'  print(tmp)
#'  print(names(tmp))
#'  print(as.numeric(tmp[1:3]))
#'  print("still need a full example for this function")
#' }
makefilename <- function(hcrLabel,runlabel,reps,initDepl) {
  dates <- splitDate()   # Devise filenames for this run from its details and date
  if (nchar(runlabel) == 0) {
    fileadd <- paste(hcrLabel,reps,initDepl,dates[5],sep="_")
  } else { fileadd <- paste(hcrLabel,reps,initDepl,dates[5],runlabel,sep="_")
  }
  return(fileadd)
}  # end of makefilename


#' @title makeLabel converts a vector of numbers or strings into a label
#'
#' @description makeLabel converts a vector of numbers or strings into a
#'     single label
#'
#' @param invect the input vector of numbers or strings
#' @param insep the seperator between each part of the label
#'
#' @return a text string
#' @export
#'
#' @examples
#' \dontrun{
#'  x <- 1:5
#'  makeLabel(x,insep="_")
#'  makeLabel(x,insep="-")
#' }
makeLabel <- function(invect,insep="_") {
  nlab <- length(invect)
  invect <- as.character(invect)
  ans <- invect[1]
  if (nlab > 1) for (i in 2:nlab) ans <- paste(ans,invect[i],sep=insep)
  return(ans)
}  # end of makeLabel



#' @title oneyearC conducts one year's dynamics using catch not harvest
#'
#' @description oneyearC conducts one year's dynamics in the simulation
#'     using catches rather than harvest rates. The harvest rates are
#'     estimated after first estimating the exploitable biomass.
#'     returning the revised zoneD, which will have had a single year
#'     of activity included in each of its components.
#'
#' @param zoneC the constant portion of the zone with a list of
#'     properties for each population
#' @param zoneDP the dynamics portion of the zone, with matrices and
#'     arrays for the dynamic variables of the dynamics of the
#'     operating model
#' @param catchp a vector of catches to be taken in the year from each
#'     population
#' @param year the year of the dynamics, would start in year 2 as year
#'     1 is the year of initiation.
#' @param iter the specific replicate being considered
#' @param sigmar the variation in recruitment dynamics, set to 1e-08
#'     when searching for an equilibria.
#' @param Ncl the number of size classes used to describe size, global Nclass
#' @param npop the number of populations, the global numpop
#' @param movem the larval dispersal movement matrix, global move
#'
#' @return a list containing a revised dynamics list
#' @export
#'
#' @examples
#' print("Wait on new data")
#' # data(zone)
#' # zoneC <- zone$zoneC
#' #  glb <- zone$glb
#'  #zoneD <- zone$zoneD
#'  #Nc <- glb$Nclass
#'  #hyrs <- glb$hyrs
#'  #catch <- 900.0 # larger than total MSY ~ 870t
#'  #B0 <- getvar(zoneC,"B0")
#'  #totB0 <- sum(B0)
#'  #prop <- B0/totB0
#'  #catchpop <- catch * prop
#'  #for (yr in 2:hyrs)
#'  #  zoneD <- oneyearC(zoneC=zoneC,zoneD=zoneD,Ncl=Nc,
#'  #                  catchp=catchpop,year=yr,sigmar=1e-08,
#'  #                  npop=glb$numpop,movem=glb$move)
#'  #str(zoneD)
#'  #round(zoneD$catchN[60:105,1:5,1],1)
oneyearC <- function(zoneC,zoneDP,catchp,year,iter,sigmar,Ncl,npop,movem) {
  matb <- numeric(npop)
  for (popn in 1:npop) {  # year=2
    out <- oneyearcat(inpopC=zoneC[[popn]],inNt=zoneDP$Nt[,year-1,popn,iter],
                      Nclass=Ncl,incat=catchp[popn],yr=year)
    zoneDP$exploitB[year,popn,iter] <- out$ExploitB
    zoneD$matureB[year,popn] <- out$MatureB
    zoneD$catch[year,popn] <- out$Catch
    zoneD$harvestR[year,popn] <- out$Harvest
    zoneD$cpue[year,popn] <- out$ce
    zoneD$Nt[,year,popn] <- out$Nt
    zoneD$catchN[,year,popn] <- out$CatchN
    matb[popn] <- out$MatureB
  }
  steep <- getvect(zoneC,"steeph") #sapply(zoneC,"[[","popdef")["steeph",]
  r0 <- getvar(zoneC,"R0") #sapply(zoneC,"[[","R0")
  b0 <- getvar(zoneC,"B0") #sapply(zoneC,"[[","B0")
  recs <- oneyearrec(steep,r0,b0,matb,sigR=sigmar)
  newrecs <- movem %*% recs
  zoneD$recruit[year,] <- newrecs
  zoneD$Nt[1,year,] <- newrecs
  zoneD$deplsB[year,] <- zoneD$matureB[year,]/b0
  zoneD$depleB[year,] <- zoneD$exploitB[year,]/getvar(zoneC,"ExB0")
  return(zoneD)
} # end of oneyearC



#' @title product is the productivity curve matrix from doproduction
#'
#' @description product is the productivity curve matrix from
#'     doproduction when the example zone is generated using the
#'     inbuilt datasets ctrl, zone1, and constants. The slowest
#'     part of building the whole is to use the modregC function
#'     to adjust the zoneC and generate the production array. To
#'     save that time in the examples (to avoid time limits on
#'     examples should this package go to CRAN), then this dataset can
#'     be used instead. This is a three dimensional array of
#'     productivity variables.
#'
#' @name product
#'
#' @docType data
#'
#' @section contents:
#' \itemize{
#'   \item harvestrate the initial harvest rates applied
#'   \item productivity variables ExB, MatB, AnnH, Catch, Deplet, RelCE
#'   \item population the index of each population
#' }
#'
#' @examples
#'  data(product)
#'  product[1:20,,1]
NULL

#' @title testzoneC is a zone list made up of 6 equilibrium populations
#'
#' @description testzoneC is a zone list made up of 6 equilibrium
#'     populations. These have been run with a laral dispersal rate of
#'     0.03 so the change from B0 to effB0 is not great, but still
#'     required for an initial equilibrium. This is here to simplify
#'     the internal testing of funcitons that require a completed
#'     zone starting at equilibrium. Its name is to avoid conflict
#'     with any actual use of zoneC. use str(testzoneC, max.level=1)
#'     to see its format. It can be expected to be used with testzoneD
#'
#' @name testzoneC
#'
#' @docType data
#'
#' @section Subjects:
#'  \itemize{
#'    \item testing of functions that require a full zone
#'    \item initial equilibrium
#'  }
#'  @export
#'
#' @examples
#'  data(testzoneC)
#'  data(testzoneD)
#'  data(zone1)
#'  glb <- zone1$globals
#'  r0 <- getvar(testzoneC,"R0")
#'  move <- makemove(glb$numpop,r0,glb$larvdisp)
#'  glb$move <- move
#'  ans <- testequil(testzoneC, testzoneD, glb)
#'  str(testzoneC[[1]])
NULL

#' @title testzoneD is a list of 8 matrices and 2 arrays defining the dynamics of a zone
#'
#' @description testzoneD is a list of 8 matrices and 2 arrays defining
#'     the dynamics of a zone. These have been run with a larval
#'     dispersal rate of 0.03 to achieve an initial equilibrium. This
#'     is here to simplify the internal testing of functions that
#'     require a completed zone starting at equilibrium. Its name is
#'     to avoid conflict with any actual use of zoneD. use
#'     str(testzoneD, max.level=1) to see its format. It can be
#'     expected to be used with testzoneC.
#'
#' @name testzoneD
#'
#' @docType data
#'
#' @section Subjects:
#'  \itemize{
#'    \item testing of functions that require a full zone
#'    \item initial equilibrium
#'  }
#'  @export
#'
#' @examples
#'  data(testzoneC)
#'  data(testzoneD)
#'  data(zone1)
#'  glb <- zone1$globals
#'  r0 <- getvar(testzoneC,"R0")
#'  move <- makemove(glb$numpop,r0,glb$larvdisp)
#'  glb$move <- move
#'  ans <- testequil(testzoneC, testzoneD, glb)
#'  str(testzoneD)
NULL


#' @title plothistcatch plots the historical catches used for conditioning
#'
#' @description plothistcatch provides a visual representation of the catches
#'     taken in each SAU/population used in the conditioning of the
#'     Operating Model.
#'
#' @param zone1 The zonewide properties as in readzonefile(indir,ctrl$zonefile)
#' @param pops default = NULL. The plot can be restricted to a specific set
#'     of populations by providing the indices of the populations to be
#'     included. Thus if there were 8 populations the pops=c(1,2,3,8), would
#'     plot the first three and the last population.
#' @param rundir the results directory used by makehtml to store plots and
#'     tables. If set to "", the default, then it plots to the console
#' @param defpar define the plot parameters. Set to FALSE if using
#'     plothistcatch to add a plot to a multiple plot
#'
#' @return nothing, it adds a plot into rundir and modifies resultTable.csv
#' @export
#'
#' @examples
#' print("wait until I have altered the internals data sets")
plothistcatch <- function(zone1,pops=NULL,rundir="",defpar=TRUE) {
  # zone1=zone1; pops=c(1,2,3,8); defpar=FALSE;  rundir=rundir
  glb <- zone1$globals
  if (length(pops) > 0) {
    histcatch <- as.matrix(zone1$histCatch[,pops])
    numpop <- length(pops)
    addlab <- paste0(pops,"_",collapse="")
    label <- paste0("p",pops)
    numpop <- length(pops)
  } else {
    histcatch <- zone1$histCatch
    addlab <- "all"
    label <- colnames(histcatch)
    numpop <- glb$numpop
  }
  histyr <- zone1$histyr
  yearCE <- zone1$yearCE
  yearC <- histyr[,"year"]
  pngfile <- paste0("Historical_Catches_",addlab,".png")
  if (nchar(rundir) > 0) {
    filen <- filenametopath(rundir,pngfile)
  } else { filen <- "" }
  if (defpar)
    plotprep(width=7,height=4,newdev=FALSE,filename=filen,cex=0.9,verbose=FALSE)
  ymax <- getmax(histcatch)
  plot(yearC,histcatch[,1],type="l",lwd=2,xlab="Year",
       ylab="Catch (t)",panel.first=grid(),ylim=c(0,ymax))
  if (numpop > 1) for (pop in 2:numpop)
    lines(yearC,histcatch[,pop],lwd=2,col=pop)
  legend("topright",label,lwd=3,col=c(1:numpop),bty="n",cex=1.2)
  if (nchar(rundir) > 0) {
    caption <- "The historical catch used for conditioning for each population."
    addplot(filen,rundir=rundir,category="history",caption)
  }
} # end of plothistcatch

#' @title plothistCE plots the historical cpue used for conditioning
#'
#' @description plothistCE provides a visual representation of the cpue
#'     taken in each SAU used in the conditioning of the
#'     Operating Model.
#'
#' @param zone1 The zonewide properties as in readzonefile(indir,ctrl$zonefile)
#' @param pops default = NULL. The plot can be restricted to a specific set
#'     of populations by providing the indices of the populations to be
#'     included. Thus if there were 8 populations the pops=c(1,2,3,8), would
#'     plot the first three and the last population.
#' @param rundir the results directory used by makehtml to store plots and
#'     tables.
#'
#' @return nothing, it adds a plot into rundir and modifies resultTable.csv
#' @export
#'
#' @examples
#' print("wait until I have altered the internals data sets")
plothistCE <- function(zone1,pops=NULL,rundir="") {
  # zone1=zone1; pops=c(1,2,3,8);
  glb <- zone1$globals
  numpop <- glb$numpop
  if (length(pops) > 0) {
    histCE <- zone1$histCE[,pops]
    numpop <- length(pops)
    addlab <- paste0(pops,"_",collapse="")
  } else {
    histCE <- zone1$histCE
    addlab="all"
  }
  yearCE <- zone1$yearCE
  pngfile <- paste0("Historical_CPUE_",addlab,".png")
  filen <- filenametopath(rundir,pngfile)
  plotprep(width=7,height=4,newdev=FALSE,filename=filen,cex=0.9,
           verbose=FALSE)
  ymax <- getmax(histCE)
  plot(yearCE,histCE[,1],type="l",lwd=2,xlab="Year",
       ylab="Standardized CPUE",panel.first=grid(),ylim=c(0,ymax))
  if (numpop > 1) for (pop in 2:numpop)
    lines(yearCE,histCE[,pop],lwd=2,col=pop)
  label <- colnames(histCE)
  legend("topright",label,lwd=3,col=c(1:numpop),bty="n",cex=1.2)
  caption <- "The historical CPUE used for conditioning for each population."
  addplot(filen,rundir=rundir,category="history",caption)
} # end of plothistCE



#' @title plotzoneproj plots the replicates of a single zone-wide variable
#'
#' @description plotzoneproj takes the results from the function aszone, which
#'     contains a set of variables zonesB, zoneeB, zoneC, zoneH, zoneR, zonece,
#'     zonedeplsB,and zonedepleB, and plots whichever is selected. It contains
#'     the option of also plotting the median and the inner 90 percent quantiles
#'     of each year's spread of values across replicates. DEPRECATED
#'
#' @param zoneV the variable from within the output of aszone
#' @param reps the number of replicates to plot. Generaly one would plot all of
#'     them. If not then it might be best to turn addqnts to FALSE
#' @param yrs the vector of years as in 1:(inityrs + projyrs)
#' @param label the y-axis label, which should obviously reflect which variable
#'     is chosen from the zone summary list.
#' @param addqnts should the median and inner 90 percent quantiles be added to
#'     the plot; default = TRUE
#' @param miny sets the lower limit of the y-axis, default=0
#'
#' @return if addqnts=TRUE the quantiles are returned invisibly
#' @export
#'
#' @examples
#' print("wait on more time")
#' # zoneV=zoneproj$zoneC;reps=reps;yrs=1:50;miny=0;label="Catches"; addqnts=TRUE
plotzoneproj <- function(zoneV,reps,yrs,label="",addqnts=TRUE,miny=0) {
  maxy <- getmax(zoneV)
  ylabel <- "Variable"
  if (nchar(label) > 0) ylabel <- label
  plot(yrs,zoneV[,1],type="n",panel.first=grid(),ylim=c(miny,maxy),yaxs="i",
       ylab=ylabel,xlab="Years")
  for (iter in 1:reps) lines(yrs,zoneV[,iter],lwd=1,col="grey")
  if (addqnts) {
    CI <- apply(zoneV,1,quantile,probs=c(0.05,0.5,0.95))
    lines(yrs,CI[1,],lwd=2,col=4)
    lines(yrs,CI[2,],lwd=2,col=2)
    lines(yrs,CI[3,],lwd=2,col=4)
  }
  if (addqnts) return(invisible(t(CI)))
} # end of plotzoneproj

#' @title plotproj aids the plotting of a projected variable
#'
#' @description plotproj plots out the projections from the MSE for a selected
#'     variable. iters is included so that details of a few trajectories can
#'     be viewed as well as seeing all replicates. DEPRECATED
#'
#' @param invar the array containing the year x SAU x reps values for a selected
#'     variable out of sauzoneDP
#' @param varlabel the label to place along the outer Y-axis
#' @param plotconst a list containing nsau, saunames, reps, projyrs, and plts
#'     a vector of two describing the layout of plots
#' @param vline default=NULL, which means nothing extra is plotted. If given a
#'     year then a vertical line in red will be added to the plot
#' @param iters default=0, which means all iterations will be plotted. If iters
#'     has a value then only that many trajectories will be plotted
#' @param addqnts will calculate and add the median and 90 percent quantiles
#' @param miny sets the lower limit of the y-axis, default=0
#'
#' @return nothing but it does generate a plot
#' @export
#'
#' @examples
#' print("wait on data files")
plotproj <- function(invar,varlabel,plotconst,miny=0,
                     vline=NULL,iters=0,addqnts=FALSE) {
  nsau <- plotconst$nsau
  yrs <- 1:plotconst$projyrs
  saunames <- plotconst$saunames
  reps <- plotconst$reps
  parset(plots=plotconst$plts,byrow=FALSE,margin=c(0.25,0.4,0.1,0.05),
         outmargin=c(1,1,0,0))
  for (sau in 1:nsau) { # sau=1
    maxy <- getmax(invar[,sau,])
    plot(yrs,invar[,sau,1],lwd=1,type="l",col="grey",panel.first=grid(),
         ylim=c(miny,maxy),xlab="",ylab=saunames[sau])
    trajs <- reps
    if (iters > 0) trajs <- iters
    for (iter in 1:trajs) lines(yrs,invar[,sau,iter],lwd=1,col="grey")
    if (!is.null(vline)) abline(v=vline,lwd=1,col=2)
    if (addqnts) {
      CI <- apply(invar[,sau,],1,quantile,probs=c(0.05,0.5,0.95))
      lines(yrs,CI[1,],lwd=1,col=4)
      lines(yrs,CI[2,],lwd=2,col=4)
      lines(yrs,CI[3,],lwd=1,col=4)
    }
  }
  mtext("Years",side=1,line=-0.1,outer=TRUE,cex=1.0,font=7)
  mtext(varlabel,side=2,line=-0.1,outer=TRUE,cex=1.0,font=7)
} # end of plotproj



#' @title read_conddata reads datasets used to condition the operating model
#'
#' @description read_conddata facilitates the reading of dataset used to
#'     condition the operating model. It is used in all aspects of conditioning,
#'     including attempting to model the productivity of each SAU using either
#'     production models or size-structured models. Once conditioned the catches
#'     can also be used to generate the initial depletion of the operating
#'     model, for scenarios which attempt to closely simulate the dynamics of an
#'     actual fishery. Currently, the function only reads in time-series of
#'     catches for each SAU across the years of the fishery. The current format
#'     for the input csv file should have the fishery name in the first line,
#'     then a heading NYRS with the number of years following that, separated by
#'     a comma, then another heading YEARS, sau1, sau2, sau3,...,saulast,
#'     followed by nyrs lines containing the year and catches for each SAU
#'
#' @param filename the filename of the text file containing the data to be used
#'     in the conditioning.
#'
#' @return a matrix of reported catches for years vs SAU
#' @export
#'
#' @examples
#' print("set up a csv file with the format given in the description")
#' print("then call condat <- read_conddata('yourname.csv')) to read the data")
read_conddata <- function(filename) {  # filename=filen
  dat <- readLines(filename)
  sps <- gsub(",","",removeEmpty(dat[1]))
  nyrs <- getsingleNum("NYRS",dat)
  loccat <- grep("YEARS",dat)
  first <- dat[loccat]
  columns <- removeEmpty(unlist(strsplit(first,",")))
  columns[1] <- "year"
  numcol=length(columns)
  catches <- matrix(0,nrow=nyrs,ncol=numcol,dimnames=list(1:nyrs,columns))
  for (i in 1:nyrs) { # i=1
    txt <- dat[(loccat + i)]
    catches[i,] <- as.numeric(unlist(strsplit(txt,",")))
  }
  ceyrs <- getsingleNum("CEYRS",dat)
  if ((is.null(ceyrs)) | (is.na(ceyrs))) stop("CPUE data missing")
  locce <- grep("CPUE",dat)
  columns <- removeEmpty(unlist(strsplit(dat[locce],",")))
  columns[1] <- "year"
  numcol=length(columns)
  cpue <- matrix(0,nrow=ceyrs,ncol=numcol,dimnames=list(1:ceyrs,columns))
  for (i in 1:ceyrs) { # i=1
    txt <- dat[(locce + i)]
    cpue[i,] <- as.numeric(unlist(strsplit(txt,",")))
  }
  # Need to enter the LML by year and block
  ans <- list(catches=catches,cpue=cpue)
  return(ans)
} # end of read_condata

#' @title readhcrfile literally reads a csv file for controling the AbMSE
#'
#' @description readhcrfile complements the readdatafile. The MSE requires
#'     a data file to condition the operating model but it also needs a
#'     control file to setup the details of the simulation test being
#'     conducted. See ctrlfileTemplate./
#'
#' @param infile the filename of the control file
#'
#' @return a list object containing the contro variables
#' @export
#'
#' @examples
#' \dontrun{
#'   print("Still to be developed.")
#' }
readhcrfile <- function(infile) {  # infile <- "C:/A_CSIRO/Rcode/AbMSERun/ctrl_west.csv"
  indat <- readLines(infile)   # reads the whole file as character strings
  begin <- grep("batch",indat)
  batch <-  getLogical(indat[begin],1) # minimum size class
  reps <- getsingleNum("replicates",indat)
  initDepl <- getsingleNum("initDepl",indat)
  assessInterval <- getsingleNum("assessInterval",indat)
  recthreshold <- getsingleNum("recthreshold",indat)
  begin <- grep("hcrLabel",indat)
  hcrLabel <- getStr(indat[begin],1)
  begin <- grep("ConstC",indat)
  ConstC <- getLogical(indat[begin],1)
  begin <- grep("mcdaHCR",indat)
  if (length(begin) > 1) begin <- begin[2]
  mcdaHCR <- getLogical(indat[begin],1)
  begin <- grep("ConstH",indat)
  ConstH <- getLogical(indat[begin],1)
  pickSched <- getsingleNum("pickSched",indat)
  begin <- grep("TACadj",indat)
  TACadj <- getConst(indat[begin],11,2)
  begin <- grep("TACadj2",indat)
  TACadj2 <- getConst(indat[begin],11,2)
  begin <- grep("mcdaWts",indat)
  mcdaWts <- getConst(indat[begin],3,2)
  runlabel <-  paste0("_",assessInterval,"_",pickSched,"_",mcdaWts[1],"_",mcdaWts[2])
  begin <- grep("postmcdaWts",indat)
  postmcdaWts <- getConst(indat[begin],3,2)
  begin <- grep("withVariation",indat)
  withVariation <- getLogical(indat[begin],1)
  cpuePeriod <- getsingleNum("cpuePeriod",indat)
  maxGrad4 <- getsingleNum("maxGrad4",indat)
  maxRate1 <- getsingleNum("maxRate1",indat)
  begin <- grep("CETarg",indat)
  CETarg <- getConst(indat[begin],4,2)
  begin <- grep("deltaCE",indat)
  deltaCE <- getConst(indat[begin],4,2)
  implementE <- getsingleNum("implementE",indat)
  begin <- grep("LRPTAC",indat)
  LRPTAC <- getLogical(indat[begin],1)
  TACLower <- getsingleNum("TACLower",indat)
  TACUpper <- getsingleNum("TACUpper",indat)
  refyr <- getsingleNum("refyr",indat)
  withsigR <- getsingleNum("withsigR",indat)
  withsigB <- getsingleNum("withsigB",indat)
  withsigCE <- getsingleNum("withsigCE",indat)
  outctrl <- list(batch,reps,initDepl,assessInterval,runlabel,
                  recthreshold,hcrLabel,mcdaHCR,ConstC,mcdaWts,postmcdaWts,
                  pickSched,TACadj,TACadj2,withVariation,cpuePeriod,maxGrad4,
                  maxRate1,CETarg,deltaCE,
                  implementE,LRPTAC,TACLower,TACUpper,refyr,ConstH,
                  withsigR,withsigB,withsigCE)
  names(outctrl) <- c("batch","reps","initDepl","assessInterval","runlabel",
                      "recthreshold","hcrLabel","mcdaHCR","ConstC","mcdaWts",
                      "postmcdaWts","picksched","TACadj","TACadj2",
                      "withVariation","cpuePeriod","maxGrad4","maxRate1",
                      "CETarg","deltaCE","implementE","LRPTAC","TACLower",
                      "TACUpper","refyr","ConstH","withsigR","withsigB",
                      "withsigCE")
  return(outctrl)
} # end of readhcrfile


#' @title resetSel alters the selectivity of all popualtions
#'
#' @description resetSel alters the selectivity of all populations before
#'     proceeding with further dynamics
#'
#' @param inzone the simulated zone
#' @param inLML the new LML
#' @param glob the global variables object
#'
#' @return a revised zone
#' @export
#'
#' @examples
#' \dontrun{
#'   print("develop an example.")
#'
#' }
resetSel <- function(inzone,inLML,glob) {  # inzone <- zone; inLML <- testLML
  outzone <- inzone
  hyrs <- glob$hyrs
  nblock <- glob$nblock
  Nclass <- glob$Nclass
  midpts <- glob$midpts
  numpop <- glob$numpop
  useLML <- matrix(rep(inLML,hyrs),nrow=hyrs,ncol=nblock,byrow=TRUE)
  zSelect <- matrix(0,nrow=Nclass,ncol=hyrs,dimnames=list(midpts,1:hyrs))
  for (pop in 1:numpop) {  #  pop <- 1
    popparam <- inzone[[pop]]$popdef
    blk <- popparam["block"]
    verLML <- unique(useLML[,blk])
    selL50 <- popparam["SelP1"]
    selL95 <- popparam["SelP2"]
    for (LML in verLML) {
      Sel <- logistic((LML+selL50),(LML+selL95),midpts)    # uses SelP1 and SelP2
      pick <- which(useLML[,blk] == LML)
      zSelect[,pick] <- rep(Sel,length(pick))
      outzone[[pop]]$LML[pick] <- LML
    }
    outzone[[pop]]$Select <- zSelect
    outzone[[pop]]$SelWt <- zSelect * outzone[[pop]]$WtL
  }
  return(outzone)
}



#' @title scaletoOne divides a vector by its means to scale it to mean = 1.0
#'
#' @description scaletoOne divides a vector by its mean which scales it
#'     to have a mean of 1.0
#'
#' @param invect te vector in need of re-scaling
#'
#' @return a rescaled vector
#' @export
#'
#' @examples
#' \dontrun{
#'   x <- 1:9
#'   y <- scaletoOne(x)
#'   cbind(x,y)
#' }
scaletoOne <- function(invect) {
  avCE <- mean(invect,na.rm=T)
  invect <- invect/avCE
  return(invect)
} # end of scaleto1

