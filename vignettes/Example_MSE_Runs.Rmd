---
title: "Example aMSE Runs"
author: "Malcolm Haddon"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Example aMSE Runs}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

<style type="text/css">
  body, td {
     font-size: 18px;
     font-family: "Times New Roman", Times, serif;
  }
  code.r{
    font-size: 12px;
  }
  pre {
    font-size: 8px
  }
  h1 {
    font-size: 32px
  }
  .inline{
     font-size: 15px;
  }
  .display{
     font-size: 18px;
  }
</style>


<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: { 
      equationNumbers: { 
            autoNumber: "all",
            formatNumber: function (n) {return '3.'+n}
      } 
  }
});
</script>


```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  echo = TRUE,
  message = FALSE,
  warning = FALSE
)

options(knitr.kable.NA = "",
        knitr.table.format = "pandoc")

options("show.signif.stars"=FALSE,
        "stringsAsFactors"=FALSE,
        "max.print"=50000,
        "width"=240)

library(aMSE)
library(rutilsMH)
library(makehtml)
library(knitr)
library(captioner)

tab_nums <- captioner(prefix = "Table")
fig_nums <- captioner(prefix = "Figure")
pgwid=80     
```

# Introduction

The __aMSE__ software, like any spatially detailed model, has many complexities and options. Even getting started with such software is a potentially daunting challenge. The intent of this document is to present a series of examples to illustrate what can be achieved with even a basic understanding of the __aMSE__ internal details. It is recommended that any potential user also familiarize themselves with the other vignettes within __aMSE__, especially _the_data_files_, _Model_Documentation_, and _Conditioning_the MSE_.

However, here we will focus on practical examples. These will include:

* using the built in data-sets
* using the data file templates to get started
* generating and characterizing the properties of the equilibrium unfished zone (important for when conditioning the model on a real fishery).
* examining the effect of the LML on productivity in a spatially structured abalone zone.
* examining the effect of the assumed natural mortality on productivity and size-structure.

# The Initial Equilibrium Zone

The starting place for every analysis is to produce an unfished, equilibrium zone, made up of a series of SAU, each containing a number of populations. This would normally entail using at least a _control.csv_ file and a _population.csv_ file. In this first example, we will not require any further files. The _control.csv_ file is stored in the results directory (_resdir_) for the particular run/scenario it is intended to represent. This would be defined at the start of any R file you use to contain the code needed to run the example:

```{r }
library(aMSE)
library(rutilsMH)
library(makehtml)
library(knitr)
# of course, a user would always select their own directory and resdir name 
if (dir.exists("c:/Users/User/DropBox")) {
  ddir <- "c:/Users/User/DropBox/A_code/"
} else {
  ddir <- "c:/Users/Malcolm/DropBox/A_code/"
}
resdir <- paste0(ddir,"aMSEUse/conddata/generic")
dirExists(resdir,make=TRUE,verbose=TRUE)

```

Once such details are sorted out then we can start by generating the unfished, equilibrium zone. Usually, one would use functions to read the _control.csv_ that is held in the _resdir_, but here we will use an internal data-set called _zone_ that contains the list of lists that is output from calling the function _makeequilzone_.

```{r makezone }
# zone <- makeequilzone(resdir,"control2.csv") # normally would read in a file
data(zone)
str(zone,max.level = 1) # zone is an R list of 7 R lists
```



```{r }
# equilibrium zone characterization---------------------------------------------
resfile <- setuphtml(resdir)# prepare to save and log results
glb <- zone$glb
plotproductivity(resdir,zone$product,glb)
biology_plots(resdir, glb, zone$zoneC)
numbersatsize(resdir, glb, zone$zoneD)

endtime <- as.character(Sys.time())

reportlist <- list(starttime=starttime,endtime=endtime,
                   zoneC=zone$zoneC, zoneD=zone$zoneD, product=zone$product,
                   glb=glb,constants=zone$constants)
runnotes <- "This is a bare-bones example."
# If you unhash this component it will generate a local website inside
# resdir and open it so you can see the results so far.
make_html(replist=reportlist,resdir=resdir,width=500,
          openfile=TRUE,runnotes=runnotes,verbose=FALSE,
          packagename = "aMSE",htmlname="testrun")
```


```{r andMSY}

wtedmean <- function(x,wts) {
  pwts <- wts/sum(wts,na.rm=TRUE)
  ans <- sum((x * pwts),na.rm=TRUE)
  return(ans)
}


getMSY <- function(product) { # product=out$product
  bypop <- findmsy(product)
  msy <- sum(bypop[,"Catch"])
  annH <- wtedmean(bypop[,"AnnH"],bypop[,"Catch"])
  depl <- wtedmean(bypop[,"Deplet"],bypop[,"Catch"])
  return(c(msy=msy,annH=annH,depl=depl))
}
getMSY(zone$product)
```


## The Effect of LML and M on Productivity

To examine the effects of the initial LML and of natural mortality, M, on productivity in the size-structured model we have put together, we need to read in the different _.csv_ files directly rather than using _makeequilzone_

```{r }
if (dir.exists("c:/Users/User/DropBox")) {
  ddir <- "c:/Users/User/DropBox/A_code/"
} else {
  ddir <- "c:/Users/Malcolm/DropBox/A_code/"
}
resdir <- paste0(ddir,"aMSEUse/conddata/generic")
dirExists(resdir,make=TRUE,verbose=TRUE)

starttime <- (Sys.time())  # Not strictly necessary but it keeps an eye on time
zone1 <- readctrlzone(resdir,infile="control2.csv") # control2.csv is in generic
ctrl <- zone1$ctrl
constants <- readdatafile(zone1$globals$numpop,resdir,ctrl$datafile)
cat("Files read, now making zone \n")
out <- setupzone(constants,zone1) # make operating model
equiltime <- (Sys.time())

zoneC <- out$zoneC         # The constant bits of the OM
zoneD <- out$zoneD         # The dynamic bits of the OM
glb <- out$glb             # glb now has the movement matrix
product <- out$product     # important bits usually saved in resdir
  # did the larval dispersal level disturb the equilibrium?
zoneD <- testequil(zoneC,zoneD,glb)
zoneC <- resetexB0(zoneC,zoneD) # rescale exploitB to avexplB after dynamics
equiltime - starttime
getMSY(product)            #  same as from data(zone)

```

Now we have the _zone1_ and _constants_ objects we can explore the effect of the initial LML and M on productivity. To do this we can alter their values within the two objects before they are used to make the equilbrium zone.

```{r }
LMLrge <- c(127,130,132,135,140,145)
nLML <- length(LMLrge)
Mrge <- c(0.125,0.15,0.175,0.2)
nM <- length(Mrge) 
numpop <- glb$numpop   # from previous code chunk
msy <- matrix(0,nrow=nM,ncol=nLML,dimnames=list(Mrge,LMLrge))
annualH <- msy
depletion <- msy
# This can take a few minutes
for (natm in 1:nM) {
  constants["Me",] <- rep(Mrge[natm],numpop)
  for (lml in 1:nLML) {
    zone1$initLML <- LMLrge[lml]
    out <- setupzone(constants,zone1)
    msy[natm,lml] <- getMSY(out$product)[1]
    annualH[natm,lml] <- getMSY(out$product)[2]
    depletion[natm,lml] <- getMSY(out$product)[3]
  }
}

round(msy,3)
cat("\n")
round(annualH,3)
cat("\n")
round(depletion,3)
```







