

#' @title calcFIS calculates required FIS data
#'
#' @description calcFIS this takes in the mid-year numbers-at-size and other
#'     details concerning the FIS and for each year and iter returns the
#'     sauNumNE (as sauNum), the fisNums, the predfis, and the fisindex.
#'
#' @param midyrNum the mid-year numbers-at-size for a specific year and
#'     iteration. the input would be midyrNum=zoneDP$NumNe[,year,,iter]
#' @param fisproj is a list of qfis, forfis, sauindedx, and fiserr, which is
#'     generated by sadmakefisproj. qfis is the catchability for the FIS in
#'     each SAu with a fis. This is stored in zoneDP. forfis a list of FIS
#'     properties including fissau and selfis, stored in hsargs. sauindex is
#'     the population indices for each SAu, stored in glb. Finally, fiserr is
#'     the mean and sd for normal random error used to generate the FIS
#'     observations from the predfis. These are the last two values in the
#'     fispar stored in hsargs.
#'
#' @return a list of predfis, fisindex, sauNUM, and fisNUms
#' @export
#'
#' @examples
#' # syntax
#' # fis <- calcFIS(fisindex=zoneDP$fisindex,fisproj)
calcFIS <- function(inNumNe,fisproj) { #
# inNumNe=zoneDP$NumNe[,year,,iter]; fisproj=fisproj
  qfis <- fisproj$qfis
  fissau <- fisproj$fissau
  nfis <- fisproj$nfis
  sauindex <- fisproj$sauindex
  fiserr <- fisproj$fiserr
  N <- dim(inNumNe)[1]
  sauNum <- matrix(0,nrow=N,ncol=nfis)
  fisNums <- predfis <- fisindex <- numeric(nfis)
  selfis <- fisproj$selfis
  for (i in 1:nfis) { #  year=46; sau = 5; i = 1
    sau <- fissau[i]
    pickC <- which(sauindex == sau)
    sauNum[,i] <- rowSums(inNumNe[,pickC])
    fisNums[i] <- sum(selfis * sauNum[,i])
    predfis[i] <- qfis[i] * fisNums[i]
    fisindex[i] <- predfis[i] + rnorm(1,mean=fiserr[1],sd=fiserr[2])
  }
  return(list(predfis=predfis,fisindex=fisindex,sauNum=sauNum,fisNums=fisNums,
              fissau=fissau))
} #end of calcFIS

# syntax sadFIS(fisindex=zoneDP$fisindex[,,iter],fisproj=fisproj,year=year)
sadFIS <- function(fisindex,fisproj,year) {
  fissau <- fisproj$fissau
  fis <- fisindex[fisproj$fisstart[2]:year,fissau]
  return(fis)
}


#syntax    fisindex=zoneDP$fisindex[,,iter],fisproj=fisproj
sadData <- function(tasCPUE, sadFIS, tasNaS, sauCPUE, sauacatch, saucatch,
                    sauNAS, year,iter,decrement, startCE,fisindex,fisproj) {
  datayear <- year - decrement
  outce <- tasCPUE(sauCPUE, year, startCE, decrement=decrement)
  yearnames <- outce$yearnames   # omit empty first year
  arrce <- outce$arrce
  acatches=sauacatch[year-1,]
  if (is.null(fisindex)) {
    fis <- NULL
  } else {
    fis <- sadFIS(fisindex=fisindex[,,iter],fisproj=fisproj,year=year)
  }
  nas <- tasNaS(sauNAS)
  ans <- list(arrce=arrce,yearnames=yearnames,acatches=acatches,fis=fis, nas=nas)
  return(ans)
} # end of sadData


sadmakeouthcr <- function(glb,hsargs) { # glb=glb; hsargs=tashsargs
  startyr <- glb$hyrs + 1
  endyr <- glb$hyrs + glb$pyrs
  saunames <- glb$saunames
  nsau <- length(saunames)
  reps <- glb$reps
  yrnames <- c(glb$hyrnames,glb$pyrnames)
  hcryrs <- yrnames[startyr]:yrnames[endyr]
  nyrs <- length(hcryrs)
  g1s <- array(0,dim=c(nyrs,nsau,reps),
               dimnames=list(hcryrs,saunames,1:reps))
  g4s <- targsc <- finalsc <- index <- catchmult <- metaflag <- cetarg <- g1s
  fisindex <- predfis <- NULL
  if (glb$useFIS) {
    fisindex <- g1s
  }
  outhcr <- list(g1s=g1s,g4s=g4s,targsc=targsc,finalsc=finalsc,index=index,
                 catchmult=catchmult,metaflag=metaflag,cetarg=cetarg,
                 fisindex=fisindex)
  return(outhcr)
} # end of sadmakeouthcr

sadmakefisproj <- function(zoneDD,hsargs,glb) {
  forfis <- hsargs$forfis
  nfis <- length(forfis$fissau)
  fisproj <- list(qfis=zoneDD$qfis,fissau=forfis$fissau,nfis=nfis,
                  selfis=forfis$selfis[,ncol(forfis$selfis)],
                  sauindex=glb$sauindex,fiserr=hsargs$fispar[3:4],
                  fisstart=forfis$fisstart)
  return(fisproj)
} # end of sadmakefisproj

sadconstantrefhcr <- function(indat,hsargs,glb,projyear,outhcr,iter) {
  # indat=hcrdata;hsargs=hsargs;glb=glb;projyear=year;outhcr=outhcr;iter=iter
  useFIS <- glb$useFIS
  saunames <- glb$saunames
  arrce <- as.matrix(indat$arrce)
  nsau <- ncol(arrce)
  yrce <- nrow(arrce)
  pmwts <- hsargs$pmwts
  stablewts <- hsargs$stablewts
  pmwtSwitch <- hsargs$pmwtSwitch
  metRunder <- hsargs$metRunder
  metRover <- hsargs$metRover
  yearnames <- indat$yearnames
  acatches <- indat$acatches
  fis <- indat$fis
  # define storage matrices
  grad1val <- matrix(0,nrow=yrce,ncol=nsau,dimnames=list(yearnames,saunames))
  grad4val <- targval <- score1 <- score4 <- scoret <- scoretot <- grad1val
  multTAC <- indexI <- grad1val
  refpts <- matrix(0,nrow=nsau,ncol=4,
                   dimnames=list(saunames,c("low","trp","high","realtrp")))
  if (length(hsargs$refperiodCE) > 0) { # allow for missing years
    refperiod <- hsargs$refperiodCE
  } else {
    refyrs <- hsargs$startCE:hsargs$endCE
    refperiod <- matrix(0,nrow=nsau,ncol=length(refyrs),
                        dimnames=list(saunames,refyrs))
    for (i in 1:nsau) refperiod[i,] <- refyrs
  }
  flagmeta <- matrix(0,nrow=yrce,ncol=nsau,dimnames=list(yearnames,saunames))
  for (sau in 1:nsau) {  #  sau=1
    pickceyrs <- match(refperiod[sau,],indat$yearnames)
    actualtarg <- apply(as.matrix(arrce[pickceyrs,]),2,quantile,probs=hsargs$targqnt,
                        na.rm=TRUE)
    pickce <- which(!is.na(arrce[,sau]))
    tmp <- getgrad1(arrce[pickce,sau])                     # grad1
    nec <- length(tmp)
    if (nec < yrce) tmp <- c(rep(NA,(yrce-nec)),tmp)
    grad1val[,sau] <- tmp
    score1[,sau] <- getscore(grad1val[,sau],mult=hsargs$mult)
    tmp2 <- getgrad4(arrce[pickce,sau],wid=hsargs$wid)      # grad4
    nec2 <- length(tmp2)
    if (nec2 < yrce) tmp2 <- c(rep(NA,(yrce-nec2)),tmp2) # allow for 6 and 13
    grad4val[,sau] <- tmp2
    score4[,sau] <- getscore(grad4val[,sau],mult=hsargs$mult)
    # Now estimate target from fixed period using targscoreconstref
    tmp3 <- targscoreconstref(arrce[pickce,sau],actualtarg[sau],
                              mult=hsargs$mult,maxtarg=hsargs$maxtarg[sau])
    nec3 <- length(pickce)
    scrs <- tmp3$scores
    if (nec3 < yrce) scrs <-  c(rep(NA,(yrce-nec3)),scrs)
    scoret[,sau] <- scrs
    targval[pickce,sau] <- arrce[pickce,sau]
    scoretot[, sau] <- pmwts[1] * scoret[, sau] + pmwts[2] * score4[, sau] +
      pmwts[3] * score1[, sau]
    ## Meta Rules section
    mr3fire <- FALSE
    if (pmwtSwitch > 0) { # meta rule 3  pmwt
      # Metarule to switch weights & update scoretot
      if (all(tail(arrce[pickce, sau], pmwtSwitch) > refpts[sau, 2])) {
        tmpmr3 <- diff(arrce[, sau])
        if (all(tail(tmpmr3, pmwtSwitch) > 0)) {
          mr3fire <- TRUE
          scoretot[, sau] <- stablewts[1] * scoret[, sau] +
            stablewts[2] * score4[, sau] + stablewts[3] * score1[, sau]
          flagmeta[yrce,sau] <- 3
        }
      }
    } # meta rule 3 part 1 finished
    pickI <- floor(scoretot[,sau]) + 1 # add one to get correct hcr[index]
    pickI[pickI < 1] <- 1
    pickI[pickI > 10] <- 10
    if (pmwtSwitch > 0) {   # meta rule 3 - part 2  hcr shift CM: add
      multTAC[, sau] <- hsargs$hcrm3[pickI]
    } else {
      multTAC[, sau] <- hsargs$hcr[pickI]
    } # meta rule 3 part 2 hcr finished
    refpts[sau,] <- tmp3$rp # the only reference point is the target cpue
    # Meta Rule 1 starts  overs
    if ((metRover > 0) & (flagmeta[yrce,sau] != 3)) {
      if (all(tail(arrce[, sau], metRover) > refpts[sau, 2])) { #CE > Target for 2 years
        tmp5 <- diff(arrce[, sau])
        if (all(tail(tmp5, metRover) > 0)) {
          multTAC[yrce, sau] <- hsargs$hcr[pickI[yrce]] # already in place
        } else {
          multTAC[yrce, sau] <- 1 # if above but not increasing assign 1 to multTAC for no change
          flagmeta[yrce,sau] <- 1
        }
      }
    }  # end of meta rule 1
    if (metRunder > 0) {  # Meta Rule 2 starts under
      if (all(tail(arrce[, sau], metRunder) < refpts[sau, 2])) {
        tmp6 <- diff(arrce[, sau])
        if (all(tail(tmp6, metRunder) >= 0))  {
          multTAC[yrce, sau] <-  1 # if below and increasing 2 years assign 1 to multTAC for no change
          flagmeta[yrce, sau] <- 2
        } else {
          multTAC[yrce, sau] <- hsargs$hcr[pickI[yrce]] # already in place
        }
      }
    } # end meta rule 2
    indexI[,sau] <- pickI
  } # end of sau loop
  startyr <- glb$hyrs + 1
  inyr <- projyear - startyr + 1
  outhcr$g1s[inyr,,iter] <- score1[yrce,]
  outhcr$g4s[inyr,,iter] <- score4[yrce,]
  outhcr$targsc[inyr,,iter] <- scoret[yrce,]
  outhcr$finalsc[inyr,,iter] <- scoretot[yrce,]
  outhcr$index[inyr,,iter] <- indexI[yrce,]
  outhcr$catchmult[inyr,,iter] <- multTAC[yrce,]
  outhcr$metaflag[inyr,,iter] <- flagmeta[yrce,]
  outhcr$cetarg[inyr,,iter] <- refpts[,"trp"]
  if ((useFIS) & (!is.null(fis))) { #  use FIS
    outhcr$fisindex <- fis
  }
  acatch <- acatches * multTAC[yrce,] # to give whole numbers
  TAC <- sum(acatch,na.rm=TRUE)
  details <- list(grad4=grad4val,grad1=grad1val,targval=targval)
  out <- list(acatch=acatch,TAC=TAC,outhcr=outhcr,details=details,refpts=refpts)
  return(out)
} # end of sadconstantrefhcr

#' @title prepareforfis generates WtL and Sel for a FIS if one occurs
#'
#' @description prepareforfis in the unlikely event that one has a FIS for at
#'     least some of the SAU in the abalone zone, then it will need special
#'     treatment. Whether it should be included in the MSE and more importantly
#'     in the HCR is a matter for a jurisdictions fishery policy and each
#'     scientist's conscience. Currently, the implementation assumes that the
#'     FIS index represents the exploitable biomass (using the FIS Selectivity)
#'     in a linear fashion. So, spatial issues and hyperstability in the
#'     sampling are omitted (did I mention the scientist's conscience?). If, in
#'     the end, despite all the objections, one wants to include a FIS.
#'
#' @param fisindexdata the FIS index of relative abundance obtained from the
#'     condC object
#' @param constants the constants object, which is used to determine the
#'     weight-at-length parameters of the SAU from the populations.
#' @param glb the globals object
#' @param fispar the fispar containing selectivity parameters fisL50, delta,
#'     and the fisLML for the historical years
#'
#' @returns a list of WtL by sau with fis data, selectivity by year, yearfis
#'     the range of years with fis, fissau a vector of sau in fisindexdata,
#'     and the starting year of FIS data as a year and the index of years.
#' @export
#'
#' @examples
#' print("wait on suitable internal data sets")
#' # fisindexdata=condC$fisindexdata; glb=glb;fispar=hsargs$fispar
prepareforfis <- function(fisindexdata,glb,fispar) {
  fissau <- which(colSums(fisindexdata[,1:glb$nSAU],na.rm=TRUE) > 0)
  fisLML <- fisindexdata[,"LML"]
  pickfis <- which(fisLML > 0)
  nfis <- length(fissau)
  yearfis <- as.numeric(rownames(fisindexdata))
  whichyrfis <- match(yearfis[pickfis],glb$hyrnames)
  fisstart <- c(yearfis[1],whichyrfis[1]); names(fisstart) <- c("year","index")
  nyrfis <- length(yearfis)
  selfis <- matrix(0,nrow=glb$Nclass,ncol=nyrfis,
                   dimnames=list(glb$midpts,yearfis))
  for (i in 1:nyrfis) { # i = 14
    if (is.na(fisLML[i])) fisLML[i] <- fisLML[,(i-1)]
    selfis[,i] <- logistic(fispar["selL50"],fispar["delta"],lens=glb$midpts,
                           knifeedge = fisLML[i])
  }
  return(list(selfis=selfis,yearfis=yearfis,fissau=fissau,fisstart=fisstart,
              whichyrfis=whichyrfis,fisLML=fisLML))
} # end of prepareforfis



plotfisindex <- function(fisindex,glb,rundir,console=TRUE) {

    fisindex <- zoneDP$fisindex





} # end of plotfisindex



