
#' @title constCatch implements a constant TAC harvest strategy
#'
#' @description constCatch implements a constant catch harvest strategy. It
#'     distributes the constant TAC across the SAU with respect to the relative
#'     amounts of exploitable biomass present, including some log-normal error
#'     that uses withsigB. It still needs error to be added to the distribution
#'     of each SAUs catch among its component populations
#'
#' @param inTAC the constant catch for the zone, from projC$HSdetail
#' @param zoneDP the results list zoneDP after it has been generated by
#'     makezoneDR and then had variation added using addrepvar
#' @param glob the global object
#' @param ctrl the control object
#' @param projyrs the number of years of projection from projC$projyrs
#' @param inityrs the initial number of years used to express starting variation
#'
#' @return a revised zoneDP now containing the dynamics of each replicate run
#' @export
#'
#' @examples
#' print("wait on new data")
constCatch <- function(inTAC,zoneDP,glob,ctrl,projyrs,inityrs=10) {
  sigmar <- ctrl$withsigR
  npop <- glob$numpop
  Ncl <- glob$Nclass
  nyrs <- projyrs + inityrs
  movem <- glob$move
  reps <- ctrl$reps
  matb <- numeric(npop)
  for (iter in 1:reps) {  # iter=1
    for (year in (inityrs+1):nyrs) {
      inexpB <- zoneDP$exploitB[(year - 1),,iter]
      sauexpB <- tapply(inexpB,glob$sauindex,sum)
      divererr <- sauexpB * exp(rnorm(glob$nSAU,mean=0,sd=ctrl$withsigB))
      catbysau <- inTAC * (divererr/sum(divererr)) # currently no error on TAC
      catbypop <- catbysau[sauindex] * (inexpB/sauexpB[sauindex]) # no error on pops
      for (popn in 1:npop) { # year=11; iter=1; pop=1
        out <- oneyearcat(inpopC=zoneC[[popn]],inNt=zoneDP$Nt[,year-1,popn,iter],
                          Nclass=Ncl,incat=catbypop[popn],yr=year)
        zoneDP$exploitB[year,popn,iter] <- out$ExploitB
        zoneDP$matureB[year,popn,iter] <- out$MatureB
        zoneDP$catch[year,popn,iter] <- out$Catch
        zoneDP$harvestR[year,popn,iter] <- out$Harvest
        zoneDP$cpue[year,popn,iter] <- out$ce
        zoneDP$Nt[,year,popn,iter] <- out$Nt
        zoneDP$catchN[,year,popn,iter] <- out$CatchN
        matb[popn] <- out$MatureB
      } # pop
      steep <- getvect(zoneC,"steeph")
      r0 <- sapply(zoneC,"[[","R0")
      b0 <- sapply(zoneC,"[[","B0")
      recs <- oneyearrec(steep,r0,b0,matb,sigR=sigmar)
      newrecs <- movem %*% recs
      zoneDP$recruit[year,,iter] <- newrecs
      zoneDP$Nt[1,year,,iter] <- newrecs
      zoneDP$deplsB[year,,iter] <- zoneDP$matureB[year,,iter]/b0
      zoneDP$depleB[year,,iter] <- zoneDP$exploitB[year,,iter]/sapply(zoneC,"[[","ExB0")
    }   # year loop        zoneDR$matureB[,,1]
  }     # rep loop
  return(zoneDP)
} # end of constCatch


#' @title getaav calculates annual absolute variation in catch
#'
#' @description getaav calculates the annual absolute change in catch
#'     for an input vector of catches, which could be across a series
#'     of years or even across different spatial units for a single
#'     year (an unusual use).
#'     The equation used is aav = 100 x sum(|Ct - Ct-1|)/(sum(Ct).
#'
#' @param invect a vector of catches
#'
#' @return a single scalar value the AAV of the input catches
#' @export
#'
#' @examples
#'   catch <- c(1,2,3,4,5,4,3,2,1)
#'   getaav(catch)  # should equal 0.32
getaav <- function(invect) { # invect=x
  nyr <- length(invect)
  totC <- sum(invect,na.rm=T)
  aac <- sum(abs(invect[2:nyr] - invect[1:(nyr-1)]))
  aav <- 0.0
  if (totC > 0.0) aav <- aac/totC
  return(aav)
} # end of getaav

#' @title getgrad1 calculates the one year gradient score
#'
#' @description getgrad1 calculates the one year gradient score for a
#'    vector of CPUE. The equation used is [CE(y) / CE(y-1)] - 1,
#'    which provides the annual proportional change in CPUE.
#'
#' @param vectce vector of cpue for a given spatial scale
#'
#' @return a vector of gradient1 for each year, starting from year 2
#' @export
#'
#' @examples
#' data(blockE13)
#' nyr <- length(blockE13$year)
#' grad1 <- getgrad1(blockE13$cpue)
#' score1 <- getscore(grad1)
#' cbind(blockE13$year[2:nyr],grad1,score1)
getgrad1 <- function(vectce) {
  nyr <- length(vectce)
  grad1 <- (vectce[2:nyr]/vectce[1:(nyr-1)])-1
  return(grad1)
} # end of getgrad1


#' @title getgrad4 applies a linear regression in steps of wid to input
#'
#' @description getgrad4 takes an input vector of cpue and, in chunks
#'     of length wid, converts them to proportional changes by
#'     dividing through by the first value of the short series, then
#'     applies a linear regression keeping only the gradient.
#'
#' @param vectce the input vector of cpue
#' @param wid the number of years of the input data to use in each
#'     regression
#'
#' @return a vector of length (wid-1) shorter than the input vector
#' @export
#'
#' @examples
#' x <- c(0.0169,0.1953,0.1102,0.1511,-0.0403,-0.0247,-0.0255,-0.1089,
#'        -0.1458,-0.2082,0.0289,-0.0267)
#' grad4 <- getgrad4(x,wid=4)
#' grad3 <- getgrad4(x,wid=3)
#' cbind(c(NA,grad4),grad3)
getgrad4 <- function(vectce,wid=4) { # vectce=ab$cpue; wid=4
  nyr <- length(vectce)
  inc <- wid-1
  num <- nyr-wid+1
  x <- 1:wid
  grad4 <- numeric(num)
  for (i in 1:num) {
    propce <- vectce[i:(i+wid-1)]/vectce[i]
    grad4[i] <- coef(lm(propce ~ x))[2]
  }
  return(grad4)
} # end of getgrad4

#' @title getscore calculates the scores for the grad1 and grad4 PMs
#'
#' @description getscore calculates the scores for the grad1 and grad4
#'     performance measures. It does this by re-scaling the range of
#'     the PM values and then fitting separate linear regressions to
#'     the values above and below zero. These enable it to calculate
#'     the predicted scores.
#'
#' @param grad14 the values derived from the function getgrad1 or
#'     getgrad4
#'
#' @return a vector of scores to be included in the MCDA
#' @export
#'
#' @examples
#' data(blockE13)
#' nyr <- length(blockE13$year)
#' grad1 <- getgrad1(blockE13$cpue)
#' score1 <- getscore(grad1)
#' cbind(blockE13$year[2:nyr],grad1,score1)
getscore <- function(grad14) {
  bounds <- round((range(grad14,na.rm=TRUE) * 1.1),2)
  low <- seq(bounds[1],0.0,length=6)
  high <- seq(0.0,bounds[2],length=6)
  xax <- c(low[1:5],high)
  model1 <- lm(0:5 ~ xax[1:6])
  vars <- coef(model1)
  score <- grad14 # just to get a vector of the correct length
  pickl0 <- which(grad14 <= 0)
  score[pickl0] <- grad14[pickl0]*vars[2] + vars[1]
  model2 <- lm(5:10 ~ xax[6:11])
  vars2 <- coef(model2)
  pickg0 <- which(grad14 >= 0)
  score[pickg0] <- grad14[pickg0]*vars2[2] + vars2[1]
  return(score)
} # end of getscore

#' @title targblockHCR calculates the block scores for the targetCE
#'
#' @description targblockHCR calculates the block scores for the targetCE
#'
#' @param incpueBlock the matrix of cpue by Block by year
#' @param targetCE a vector of the targetCE for each of the blocks
#' @param modifyTarg the constant that sets the range of CPUE in the scoring
#'     function, default=1.0
#'
#' @return a vector of scores relating to the targetCE PM; used in blockMCDA
#' @export targblockHCR
#'
#' @examples
#' print("Need to use a dataset for an example")
targblockHCR <- function(incpueBlock,targetCE,modifyTarg=1.0) {
  delCE <- 5.0/modifyTarg
  score <- (delCE * incpueBlock) + 5.0 - (delCE * targetCE)
  score[score > 10.0] <- 10.0
  score[score < 0.0] <- 0.0
  return(score)  # not yet an integer
}  # end of targblockHCR



