

#' @title constCatch implements a constant TAC harvest strategy
#'
#' @description constCatch implements a constant catch harvest strategy. It
#'     distributes the constant TAC across the SAU with respect to the relative
#'     amounts of exploitable biomass present, including some log-normal error
#'     that uses withsigB. It still needs error to be added to the distribution
#'     of each SAUs catch among its component populations
#'
#' @param inTAC the constant catch for the zone, from projC$HSdetail
#' @param zoneCP the list of constants for the projections
#' @param zoneDP the results list zoneDP after it has been generated by
#'     makezoneDR and then had variation added using addrecvar
#' @param glob the global object
#' @param ctrl the control object
#' @param projyrs the number of years of projection from projC$projyrs
#' @param varyrs the number of years used to express starting variation
#'
#' @return a revised zoneDP now containing the dynamics of each replicate run
#' @export
#'
#' @examples
#' print("wait on new data")
constCatch <- function(inTAC,zoneCP,zoneDP,glob,ctrl,projyrs,varyrs=10) {
  sigmar <- ctrl$withsigR
  npop <- glob$numpop
  Ncl <- glob$Nclass
  nyrs <- projyrs + varyrs
  movem <- glob$move
  sauindex <- glob$sauindex
  reps <- ctrl$reps
  matb <- numeric(npop)
  for (iter in 1:reps) {  # iter=1
    for (year in (varyrs+1):nyrs) {
      inexpB <- zoneDP$exploitB[(year - 1),,iter] # each populations exB
      sauexpB <- tapply(inexpB,glob$sauindex,sum) # each SAU exB
      divererr <- sauexpB * exp(rnorm(glob$nSAU,mean=0,sd=ctrl$withsigB))
      catbysau <- inTAC * (divererr/sum(divererr)) # currently no error on TAC
      catbypop <- catbysau[sauindex] * (inexpB/sauexpB[sauindex]) # no error on pops
      for (popn in 1:npop) { # year=11; iter=1; pop=1
        out <- oneyearcat(inpopC=zoneCP[[popn]],inNt=zoneDP$Nt[,year-1,popn,iter],
                          Nclass=Ncl,incat=catbypop[popn],yr=year)
        zoneDP$exploitB[year,popn,iter] <- out$ExploitB
        zoneDP$matureB[year,popn,iter] <- out$MatureB
        zoneDP$catch[year,popn,iter] <- out$Catch
        zoneDP$harvestR[year,popn,iter] <- out$Harvest
        zoneDP$cpue[year,popn,iter] <- out$ce
        zoneDP$Nt[,year,popn,iter] <- out$Nt
        zoneDP$catchN[,year,popn,iter] <- out$CatchN
        matb[popn] <- out$MatureB
      } # pop
      steep <- getvect(zoneCP,"steeph")
      r0 <- sapply(zoneCP,"[[","R0")
      b0 <- sapply(zoneCP,"[[","B0")
      recs <- oneyearrec(steep,r0,b0,matb,sigR=sigmar)
      newrecs <- movem %*% recs
      zoneDP$recruit[year,,iter] <- newrecs
      zoneDP$Nt[1,year,,iter] <- newrecs
      zoneDP$deplsB[year,,iter] <- zoneDP$matureB[year,,iter]/b0
      zoneDP$depleB[year,,iter] <- zoneDP$exploitB[year,,iter]/sapply(zoneCP,"[[","ExB0")
    }   # year loop        zoneDR$matureB[,,1]
  }     # rep loop
  return(zoneDP)
} # end of constCatch


#' @title getaav calculates annual absolute variation in catch
#'
#' @description getaav calculates the annual absolute change in catch
#'     for an input vector of catches, which could be across a series
#'     of years or even across different spatial units for a single
#'     year (an unusual use).
#'     The equation used is aav = 100 x sum(|Ct - Ct-1|)/(sum(Ct).
#'
#' @param invect a vector of catches
#'
#' @return a single scalar value the AAV of the input catches
#' @export
#'
#' @examples
#'   catch <- c(1,2,3,4,5,4,3,2,1)
#'   getaav(catch)  # should equal 0.32
getaav <- function(invect) { # invect=x
  nyr <- length(invect)
  totC <- sum(invect,na.rm=T)
  aac <- sum(abs(invect[2:nyr] - invect[1:(nyr-1)]))
  aav <- 0.0
  if (totC > 0.0) aav <- aac/totC
  return(aav)
} # end of getaav


















