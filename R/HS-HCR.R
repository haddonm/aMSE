

#' @title calibrateMCDA uses historical CPUE to calibrate the MCDA
#'
#' @description calibrateMCDA uses the condC$histCE to apply the getgrad1,
#'     getgrad4, and targscore functions so as to provide vewctors of
#'     permance measure scores to enhance the calibration of the MCDA before
#'     any projections are done. This is not absolutely required but improves
#'     the reality of the process. It also means that the productivity of each
#'     SAU needs to be scaled to the current cpue (see Conditioning the MSE).
#'
#' @param histCE this is a matrix of nominal scale CPUE from the fishery of
#'     interest. Usually standardized. Obtainable from the projC object but
#'     also the condC object
#' @param saunames the names of each SAU (from zone1$SAUnames)
#'
#' @return a list of three matrices of performance measure scores used to
#'     condition the MCDA
#' @export
#'
#' @examples
#' print("wait on example data being available")
calibrateMCDA <- function(histCE,saunames) {
  # histCE <- zone$zone1$condC$histCE; saunames=zone$zone1$SAUnames
  nSAU <- length(saunames)
  yearCE <- as.numeric(rownames(histCE))
  yrce <- length(yearCE)
  grad1val <- matrix(0,nrow=yrce,ncol=nSAU,dimnames=list(yearCE,saunames))
  grad4val <- grad1val
  targval <- grad1val
  for (sau in 1:nSAU) { # sau=1
    pickce <- which(!is.na(histCE[,sau]))
    tmp <- getgrad1(histCE[pickce,sau])
    nec <- length(tmp)
    if (nec < yrce) tmp <- c(rep(NA,(yrce-nec)),tmp)
    grad1val[,sau] <- tmp
    tmp2 <- getgrad4(histCE[pickce,sau])
    nec2 <- length(tmp2)
    if (nec2 < yrce) tmp2 <- c(rep(NA,(yrce-nec2)),tmp2)
    grad4val[,sau] <- tmp2
    tmp3 <- targscore(histCE[pickce,sau])
    values <- tmp3$ans[,"targval"]
    nec3 <- length(values)
    if (nec3 < yrce) values <- c(rep(NA,(yrce-nec3)),values)
    targval[,sau] <- values
  }
  return(list(grad1val=grad1val,grad4val=grad4val,targval=targval))
} # end of calibrateMCDA


#' @title constCatch implements a constant TAC harvest strategy
#'
#' @description constCatch implements a constant catch harvest strategy. It
#'     distributes the constant TAC across the SAU with respect to the relative
#'     amounts of exploitable biomass present, including some log-normal error
#'     that uses withsigB. It still needs error to be added to the distribution
#'     of each SAUs catch among its component populations
#'
#' @param inTAC the constant catch for the zone, from projC$HSdetail
#' @param zoneCP the list of constants for the projections
#' @param zoneDP the results list zoneDP after it has been generated by
#'     makezoneDR and then had variation added using addrecvar
#' @param glob the global object
#' @param ctrl the control object
#' @param projyrs the number of years of projection from projC$projyrs
#' @param inityrs the initial number of years used to express starting variation
#' @param recvar should recruitment variation be included, default=TRUE
#'
#' @return a revised zoneDP now containing the dynamics of each replicate run
#' @export
#'
#' @examples
#' print("wait on new data")
constCatch <- function(inTAC,zoneCP,zoneDP,glob,ctrl,projyrs,inityrs=10,
                       recvar=TRUE) {
  sigmar <- ctrl$withsigR
  npop <- glob$numpop
  Ncl <- glob$Nclass
  nyrs <- projyrs + inityrs
  movem <- glob$move
  sauindex <- glob$sauindex
  reps <- ctrl$reps
  matb <- numeric(npop)
  for (iter in 1:reps) {  # iter=1
    for (year in (inityrs+1):nyrs) {
      inexpB <- zoneDP$exploitB[(year - 1),,iter] # each populations exB
      sauexpB <- tapply(inexpB,glob$sauindex,sum) # each SAU exB
      divererr <- sauexpB * exp(rnorm(glob$nSAU,mean=0,sd=ctrl$withsigB))
      catbysau <- inTAC * (divererr/sum(divererr)) # currently no error on TAC
      catbypop <- catbysau[sauindex] * (inexpB/sauexpB[sauindex]) # no error on pops
      for (popn in 1:npop) { # year=11; iter=1; pop=1
        out <- oneyearcat(inpopC=zoneCP[[popn]],inNt=zoneDP$Nt[,year-1,popn,iter],
                          Nclass=Ncl,incat=catbypop[popn],yr=year)
        zoneDP$exploitB[year,popn,iter] <- out$ExploitB
        zoneDP$matureB[year,popn,iter] <- out$MatureB
        zoneDP$catch[year,popn,iter] <- out$Catch
        zoneDP$harvestR[year,popn,iter] <- out$Harvest
        zoneDP$cpue[year,popn,iter] <- out$ce
        zoneDP$Nt[,year,popn,iter] <- out$Nt
        zoneDP$catchN[,year,popn,iter] <- out$CatchN
        matb[popn] <- out$MatureB
      } # pop
      steep <- getvect(zoneCP,"steeph")
      r0 <- sapply(zoneCP,"[[","R0")
      b0 <- sapply(zoneCP,"[[","B0")
      recs <- oneyearrec(steep,r0,b0,matb,sigR=sigmar,withvar=recvar)
      newrecs <- movem %*% recs
      zoneDP$recruit[year,,iter] <- newrecs
      zoneDP$Nt[1,year,,iter] <- newrecs
      zoneDP$deplsB[year,,iter] <- zoneDP$matureB[year,,iter]/b0
      zoneDP$depleB[year,,iter] <- zoneDP$exploitB[year,,iter]/sapply(zoneCP,"[[","ExB0")
    }   # year loop        zoneDR$matureB[,,1]
  }     # rep loop
  return(zoneDP)
} # end of constCatch


#' @title getaav calculates annual absolute variation in catch
#'
#' @description getaav calculates the annual absolute change in catch
#'     for an input vector of catches, which could be across a series
#'     of years or even across different spatial units for a single
#'     year (an unusual use).
#'     The equation used is aav = 100 x sum(|Ct - Ct-1|)/(sum(Ct).
#'
#' @param invect a vector of catches
#'
#' @return a single scalar value the AAV of the input catches
#' @export
#'
#' @examples
#'   catch <- c(1,2,3,4,5,4,3,2,1)
#'   getaav(catch)  # should equal 0.32
getaav <- function(invect) { # invect=x
  nyr <- length(invect)
  totC <- sum(invect,na.rm=T)
  aac <- sum(abs(invect[2:nyr] - invect[1:(nyr-1)]))
  aav <- 0.0
  if (totC > 0.0) aav <- aac/totC
  return(aav)
} # end of getaav

#' @title getgrad1 calculates the one year gradient score
#'
#' @description getgrad1 calculates the one year gradient score for a
#'    vector of CPUE. The equation used is [CE(y) / CE(y-1)] - 1,
#'    which provides the annual proportional change in CPUE.
#'
#' @param vectce vector of cpue for a given spatial scale
#'
#' @return a vector of gradient1 for each year, starting from year 2
#' @export
#'
#' @examples
#' data(blockE13)
#' nyr <- length(blockE13$year)
#' grad1 <- getgrad1(blockE13$cpue)
#' score1 <- getscore(grad1)
#' cbind(blockE13$year[2:nyr],grad1,score1)
getgrad1 <- function(vectce) {
  nyr <- length(vectce)
  grad1 <- (vectce[2:nyr]/vectce[1:(nyr-1)])-1
  return(grad1)
} # end of getgrad1


#' @title getgrad4 applies a linear regression in steps of wid to input
#'
#' @description getgrad4 takes an input vector of cpue and, in chunks
#'     of length wid, converts them to proportional changes by
#'     dividing through by the first value of the short series, then
#'     applies a linear regression keeping only the gradient.
#'
#' @param vectce the input vector of cpue
#' @param wid the number of years of the input data to use in each
#'     regression
#'
#' @return a vector of length (wid-1) shorter than the input vector
#' @export
#'
#' @examples
#' x <- c(0.0169,0.1953,0.1102,0.1511,-0.0403,-0.0247,-0.0255,-0.1089,
#'        -0.1458,-0.2082,0.0289,-0.0267)
#' grad4 <- getgrad4(x,wid=4)
#' grad3 <- getgrad4(x,wid=3)
#' cbind(c(NA,grad4),grad3)
getgrad4 <- function(vectce,wid=4) { # vectce=ab$cpue; wid=4
  nyr <- length(vectce)
  inc <- wid-1
  num <- nyr-wid+1
  x <- 1:wid
  grad4 <- numeric(num)
  for (i in 1:num) {
    propce <- vectce[i:(i+wid-1)]/vectce[i]
    grad4[i] <- coef(lm(propce ~ x))[2]
  }
  return(grad4)
} # end of getgrad4

#' @title getgradone calculates the one year gradient score
#'
#' @description getgradone calculates the one year gradient score for a
#'    vector of CPUE. The equation used is [CE(y) / CE(y-1)] - 1,
#'    which provides the annual proportional change in CPUE.
#'
#' @param vectce vector of cpue for a given spatial scale
#' @param yr the year for which a score is required
#'
#' @return a vector of gradient1 for each year, starting from year 2
#' @export
#'
#' @examples
#' data(blockE13)
#' nyr <- length(blockE13$year)
#' grad1 <- getgradone(blockE13$cpue,yr = 10)
#' print(grad1)
getgradone <- function(vectce,yr) {
  grad1 <- (vectce[yr]/vectce[yr-1])-1
  return(grad1)
} # end of getgradone

#' @title getgradwid returns a single gradient across a cpue vector
#'
#' @description getgradwid calculates the regression gradient of a time-series
#'     of cpue values of length wid, using the analytical formulae rather than
#'     lm (for speed)
#'
#' @param vectce the vector of cpue. it must be at least yr long
#' @param yr the last yr of the wid long time-series whose gradient is wanted
#' @param wid the number of years across which the gradient is to be estimated
#'
#' @return a single gradient
#' @export
#'
#' @examples
#' vectcpue <- c(0.867,0.885,0.877,1.008,1.169,1.231,1.226,1.237,1.238,1.156)
#' getgradwid(vectcpue,yr=10)   #  -0.01704731
getgradwid <- function(vectce,yr,wid=4) {
  inc <- wid-1
  yrrge <- (yr-inc):yr
  x <- 1:wid
  xres <- (x-mean(x,na.rm=TRUE))
  propce <- vectce[yrrge]/vectce[yr-inc]
  yres <- (propce - mean(propce,na.rm=TRUE))
  x2 <- sum(xres^2)
  xy <- sum(xres * yres)
  return(xy/x2)
} #end getgradwid

#' @title getlmcoef is a greatly simplified way of gasining regression coefs
#'
#' @description getlmcoef is a simplified replacement for the lm function that
#'     is much faster than lm but only returns the linear regression
#'     coefficients. This is limited to a simple y ~ x model. When in use be
#'     sure to give it the values of y required.
#'
#' @param y the dependent variable
#' @param x the independent variable
#'
#' @return a vector of the intercept and gradient, in that order.
#' @export
#'
#' @examples
#' y <- c(1.226,1.237,1.238,1.156)
#' x <- 1:4
#' yp <- y/y[1]  # to make the cpue relative to the first in the series
#' getlmcoef(yp,x)
#' getgradwid(yp,4)
getlmcoef <- function(y,x) {
  mx <- mean(x,na.rm=TRUE)
  xres <- (x-mx)
  my <- mean(y,na.rm=TRUE)
  yres <- (y - my)
  x2 <- sum(xres^2)
  xy <- sum(xres * yres)
  grad <- xy/x2
  inter <- my - grad*mx
  return(c(inter,grad))
}

#' @title getscore calculates the scores for the grad1 and grad4 PMs
#'
#' @description getscore calculates the scores for the grad1 and grad4
#'     performance measures. It does this by re-scaling the range of
#'     the PM values and then fitting separate linear regressions to
#'     the values above and below zero. These enable it to calculate
#'     the predicted scores.
#'
#' @param grad14 the raw values derived from the function getgrad1 or
#'     getgrad4
#' @param mult the multiplier on the bounds to expand them upwards and
#'     downwards. default value = 1.1 = 10 percent increase
#'
#' @return a vector of scores to be included in the MCDA
#' @export
#'
#' @examples
#' data(blockE13)
#' nyr <- length(blockE13$year)
#' grad1 <- getgrad1(blockE13$cpue)
#' score1 <- getscore(grad1)
#' cbind(blockE13$year[2:nyr],grad1,score1)
getscore <- function(grad14,mult=0.1) {   # grad14=grad4; mult=1.1
  bounds <- round((range(grad14,na.rm=TRUE) * mult),2)
  if (bounds[1] > -0.05) bounds[1] <- -0.05
  if (bounds[2] <= 0) bounds[2] <- 0.05
  low <- seq(bounds[1],0.0,length=6)
  high <- seq(0.0,bounds[2],length=6)
  xax <- c(low[1:5],high)
  vars <- getlmcoef(0:5,xax[1:6])
  score <- grad14 # just to get a vector of the correct length
  pickl0 <- which(grad14 <= 0)
  score[pickl0] <- grad14[pickl0]*vars[2] + vars[1]
  vars2 <- getlmcoef(5:10,xax[6:11])
  pickg0 <- which(grad14 >= 0)
  score[pickg0] <- grad14[pickg0]*vars2[2] + vars2[1]
  return(score)
} # end of getscore

#' @title mcdahcr conducts the MCDA and returns the TAC multiplier and details
#'
#' @description mcdahcr conducts the MCDA on the basis of a vector of cpue and
#'      other details prescribed in the function's arguments. It returns the
#'      TAC multiplier, the combined score, and all the details of the
#'      calculation. The hcr is a vector of 1:10 values where the cell index
#'      is used to allocate each combined score to a multiplier. The score is
#'      rounded up to the nearest integer and that is the index within hcr.
#'      Thus a score of <=1 points to the first cell, >1 and <=2 points to the
#'      second cell, and so on, up to a score between >9 and <=10 which points
#'      to the last cell.
#'
#' @param vectce the vector of cpue that forms the basis of the assessment
#' @param yr the year for which a score is required
#' @param wid the number of years to use in grad4, default=4
#' @param targqnt the quantile for the cpue target level, default=0.55
#' @param pmwts performance measure weights, default = 0.65, 0.25, 0.1 for the
#'     target, grad4, and grad1 PMs respectively. So the order matters.
#' @param hcr the harvest control rule scales that transform the combined score
#'     into a TAC multiplier. A vector of 1 - 10 where each cell index
#'     represents the upper limit of the the combined score.
#' @param only should the function only return the score or all details. TRUE
#'     implies only return the score
#'
#' @return a list of the TAC multiplier, the score, and all the details
#' @export
#'
#' @examples
#' print("wait on data and time")
mcdahcr <- function(vectce,yr, wid=4,targqnt=0.55,pmwts=c(0.65,0.25,0.1),
                    hcr=c(0.25,0.75,0.8,0.85,0.9,1,1.05,1.1,1.15,1.2),
                    only=TRUE) {
  grad4 <- getgradwid(vectce,yr,wid=wid)
  score4 <- getscore(grad4)
  grad1 <- getgradone(vectce,yr)
  score1 <- getscore(grad1)
  scoret <- targscore(vectce,qnt=targqnt)
  score <- pmwts[1]*scoret$result + pmwts[2]*score4 +
    pmwts[3]*score1
  pick <- ceiling(score)
  if (pick < 1) pick <- 1
  if (pick > 10) pick <- 10
  multTAC <- hcr[pick]
  if (only) {
    return(multTAC)
  } else {
    details <- list(grad4,score4,grad1,score1,scoret)
    out <- list(multTAC=multTAC, score=score,details=details)
    return(out)
  }
} # end of mcdahcr


#' @title targscore generates the HCR score for the target PM
#'
#' @description targscore takes in a vector of cpue and define the targ from
#'     the complete series as well as the limit reference point and an upper
#'     level that is symmetrically spaced around the
#'
#' @param vectce the vector of cpue to be assessed
#' @param qnt the quantile of the input vector selected as the target,
#'     default = 0.55
#'
#' @return a list of the final year's score, the internals to the calculations,
#'     and he target and limit reference points
#' @export
#'
#' @examples
#' print("wait on suitable data")
targscore <- function(vectce,qnt=0.55) { # vectce=saucpue[1:inityrs,sau,iter];qnt=targqnt
  targ <- quantile(vectce,probs <- c(qnt))
  limrp <- min(vectce)*0.9
  uprp <- (targ + (targ - limrp))
  targval <- vectce - targ
  targsc <- getscore(targval)
  ans <- as.matrix(cbind(vectce,targval,targsc))
  dimnames(ans) <- list(1:length(vectce),c("cpue","targval","targsc"))
  details <- c(targ,limrp); names(details)=c("target","limit")
  result <- tail(targsc,1)
  return(list(result=result,ans=ans,details=details))
} # end of targscore

















