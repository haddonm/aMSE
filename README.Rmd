---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# aMSE

<!-- badges: start -->
<!-- badges: end -->

This packages up a new Abalone Management Strategy Evaluation framework. It has a novel structure that is based around the spatial ideas of populations within spatial management units (SAUs), within a zone:

* zone - highest geogrpahical level. Is simply the totality of the spatial management units.

* SAU - spatial assessment units. In Tasmania these would currently be the classical statistical blocks.

* population - literally a population. These are the active components within the simulation framework. The dynamics of the simulation are based around the populations, although, with positive larval dispersal (the default) there is some dependency of neighbouring populations on each other.


This conceptual structure has implications for how the simulations are conditioned during the management strategy testing. While it is still the case that the general properties of each SAU are used to set the scene for each SAU's component populations, the advent of sufficient GPS logger data now allows a more formal definition of the productivity of each population. Currently, the modelling assumes that each population is linearly arranged around the coastline, and this will allow, where available, specific catch/yield data to be used to define the bounds of each population within an SAU. 

An important change from previous designs is that larval dispersal is implemented explicitly rather than implicitly being held constant. This alters the dynamics so that analytical equilibrium methods no longer work and we need to resort to iterative approaches to equilibrium if the larval dispersal rate is > 0.0.

Of course, adding such a component increases the number of options that may need to be explored, but currently we envisage including a very low, a middle range, and a relatively high level of larval dispersal, to examine its implications.

## Installation

Once the MSE framework is made public you can install the development version from [GitHub](https://github.com/haddonm/aMSE) with:

```{r echo=TRUE, eval=FALSE}
if (!require(devtools)){install.packages("devtools")} 

devtools::install_github("https://github.com/haddonm/aMSE",build_vignettes = TRUE)
```

Alternatively, while the development version remains private, you can generate a branch that you can work on by cloning the repository, which, again, can be done very simply within RStudio. Open the New Project option in the project dialog at the top right of the RStudio screen and selection Version Control, then use 'https://github.com/haddonm/aMSE' in the top box, identify where you want the new directory put, and press return. ALternatively, you could download the zip file from inside the 'code' button and establish an R project from that.

It would be a good idea to read Hadley Wickham's draft chapter on Git and GitHub at https://r-pkgs.org/index.html.


## Example

This is a basic example which illustrates the generation of an initial equilibrium. It uses built in data-sets but usually you would generate zoneC (constants) and zoneD (the dynamic components) from the conditioning data:

```{r example, echo=TRUE}
# a constant TAC example
starttime <- (Sys.time())
library(aMSE)
library(rutilsMH)
library(makehtml)
library(knitr)
# Obviously you should modify the resdir to suit your own computer
if (dir.exists("c:/Users/User/DropBox")) {
  ddir <- "c:/Users/User/DropBox/A_code/"
} else {
  ddir <- "c:/Users/Malcolm/DropBox/A_code/"
}
resdir <- paste0(ddir,"aMSEUse/conddata/generic2")  # data and results directory
dirExists(resdir,make=TRUE,verbose=TRUE)
# equilibrium zone -------------------------------------------------------------
# You now need to ensure that there is, at least, a control.csv, zone1.csv
# and region1.csv file in the data directory plus some other data .csv files
# depending on how conditioned you want the model to be. Templates for the
# correct format can be produced using ctrlfiletemplate(), datafiletemplate(),
# and zonefiletemplate.  In the meantime it is easier to use the included 
# data files. The original csv files are included in the data-raw directory
data(ctrl)
data(zone1)
data(constants)
ctrl$reps <- 250  # the original = 1000, we use 250 to use only 25% of the time
#zone1$initLML <- 140
out <- setupzone(constants,zone1) # make operating model
zoneC <- out$zoneC
zoneD <- out$zoneD
glb <- out$glb             # glb now has the movement matrix
product <- out$product     # important bits usually saved in resdir
# did the larval dispersal level disturb the equilibrium?
zoneD <- testequil(zoneC,zoneD,glb)
zoneC <- resetexB0(zoneC,zoneD) # rescale exploitB to avexplB after dynamics
initialC <- zoneC
unfishedD <- zoneD         # keep a copy of the unfished zone

equiltime <- (Sys.time())
print(equiltime - starttime)
# deplete generic zone ---------------------------------------------------------
zoneC <- initialC
zoneD <- unfishedD
# set the initial depletion levels if not defined in the data file
# the values below manage to achieve c(0.7,0.65,0.7,0.6,0.5,0.45,0.475,0.45)
zone1$condC$initdepl <- c(0.53,0.53,0.48,0.48,0.49,0.49,0.52,0.52,
                          0.51,0.51,0.45,0.45,0.484,0.484,0.467,0.467)
origdepl <-  zone1$condC$initdepl
zoneDD <- depletepop(zoneC,zoneD,glb,depl=origdepl,product,len=12)
propD <- getzoneprops(zoneC,zoneDD,glb,year=1)
#round(propD,2)
# setup for projection ---------------------------------------------------------
inityrs <- 10
projyrs <- zone1$projC$projyrs + inityrs
reps <- ctrl$reps
projC <- modprojC(zoneC,glb,zone1)
zoneC <- modzoneCSel(zoneC,projC$Sel,projC$SelWt,glb,projyrs)
zoneDR <- makezoneDR(projyrs,reps,glb,zoneDD) # zoneDReplicates
zoneDRp <- addrepvar(zoneC,zoneDR,zoneDR$harvestR,glb,ctrl)
midtime <- (Sys.time())
print(midtime - equiltime)
# prepare the HS --------------------------------------------------------------
if (projC$HS == "constantCatch") {
  hsFunc <- constCatch
  inTAC <- projC$HSdetail
}
if (projC$HS == "MCDA") {  # not complete yet, this will do nothing
  hsFunc <- doMCDA
  mcdafile <- projC$HSdetail
  optCE <- MCDAdata(resdir,mcdafile,zone1$SAUnames)
}
# Do the replicates ------------------------------------------------------------
inityr <- 10
saunames <- zone1$SAUnames
sauindex <- glb$sauindex
pyrs <- projC$projyrs + inityr
B0 <- tapply(sapply(zoneC,"[[","B0"),sauindex,sum)
exB0 <- tapply(sapply(zoneC,"[[","ExB0"),sauindex,sum)
# a TAC = 870t = zoneal MSY
zoneDP <- constCatch(870,zoneDRp,glb,ctrl,projC$projyrs,inityrs=10)
sauzoneDP <- asSAU(zoneDP,sauindex,saunames,B0,exB0)

endtime <- (Sys.time())
print(endtime - midtime)
#calculate the relative MSY weighted MSY-depletion level for each SAU
pmsydepl <- sapply(zoneC,"[[","MSYDepl")
pmsy <- sapply(zoneC,"[[","MSY")
smsy <- tapply(pmsy,sauindex,sum)
smsydepl <- tapply((pmsydepl * pmsy) / smsy[sauindex],sauindex,sum)

# plot the projected depletion levels of mature biomass
ans <- sauzoneDP$saudeplsB
label <- "Mature Depletion"
uplim <- 0.7
plotprep(width=7,height=8,newdev=FALSE)
parset(plots=c(4,2),byrow=FALSE,margin=c(0.25,0.4,0.1,0.05),
       outmargin=c(1,1,0,0))
yrs <- 1:pyrs
for (sau in 1:8) {
  maxy <- uplim
  if (is.null(uplim)) maxy <- getmax(ans[,sau,])
  plot(yrs,ans[,sau,1],lwd=1,col="grey",panel.first=grid(),ylim=c(0,maxy),
       xlab="",ylab=saunames[sau])
  for (iter in 1:reps) lines(yrs,ans[,sau,iter],lwd=1,col="grey")
  abline(h=smsydepl[sau],lwd=2,col=4)
  abline(v=inityr,lwd=1,col=2)
}
mtext("Years",side=1,line=-0.1,outer=TRUE,cex=1.0,font=7)
mtext(label,side=2,line=-0.1,outer=TRUE,cex=1.0,font=7)

```


See the vignette Running_aMSE.Rmd for a more detailed example.

See the New.Rd for recent developments
